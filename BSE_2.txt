import numpy as np
import matplotlib.pyplot as plt

# Parameters
S1_max, S2_max = 200, 200   # Maximum asset price
S1_min, S2_min = 0, 0       # Minimum asset price
T = 1.0                     # Time to maturity
r = 0.05                    # Risk-free rate
sigma1 = 0.2                # Volatility of asset 1
sigma2 = 0.3                # Volatility of asset 2
rho = 0.5                   # Correlation between asset returns

# Grid parameters
M1, M2, N = 50, 50, 100     # Number of price steps for S1, S2, and time steps

dS1 = S1_max / M1

dS2 = S2_max / M2
dt = T / N

# Grids
S1_grid = np.linspace(S1_min, S1_max, M1+1)
S2_grid = np.linspace(S2_min, S2_max, M2+1)

# Initialize solution grid
V = np.maximum(S1_grid[:, None], S2_grid[None, :])

# Explicit finite difference method
for n in range(N-1, -1, -1):
    V_new = V.copy()
    
    for i in range(1, M1):
        for j in range(1, M2):
            dV_dS1 = (V[i+1, j] - V[i-1, j]) / (2 * dS1)
            dV_dS2 = (V[i, j+1] - V[i, j-1]) / (2 * dS2)
            d2V_dS1 = (V[i+1, j] - 2*V[i, j] + V[i-1, j]) / (dS1**2)
            d2V_dS2 = (V[i, j+1] - 2*V[i, j] + V[i, j-1]) / (dS2**2)
            d2V_dS1S2 = (V[i+1, j+1] - V[i+1, j-1] - V[i-1, j+1] + V[i-1, j-1]) / (4 * dS1 * dS2)
            
            # Black-Scholes explicit update
            V_new[i, j] = V[i, j] + dt * (
                0.5 * sigma1**2 * S1_grid[i]**2 * d2V_dS1 +
                0.5 * sigma2**2 * S2_grid[j]**2 * d2V_dS2 +
                rho * sigma1 * sigma2 * S1_grid[i] * S2_grid[j] * d2V_dS1S2 +
                r * S1_grid[i] * dV_dS1 + r * S2_grid[j] * dV_dS2 - r * V[i, j]
            )
    
    V = V_new.copy()

# Plot the option price surface
S1_mesh, S2_mesh = np.meshgrid(S1_grid, S2_grid)
fig = plt.figure(figsize=(8, 6))
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(S1_mesh, S2_mesh, V.T, cmap='viridis')
ax.set_xlabel('S1')
ax.set_ylabel('S2')
ax.set_zlabel('Option Price')
ax.set_title('Option Price Surface for max(S1, S2)')
plt.show()
